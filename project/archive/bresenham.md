### 🧬 브레즌햄 알고리즘의 3단계 진화

가정: $(0,0)$에서 $(10, 4)$로 선을 긋습니다. ($dx=10, dy=4$)

기울기 $m = 0.4$ 입니다.

#### 1단계: 원시 버전 (Floating Point)

**"가장 직관적이지만 느린 방법"**

수학 교과서 그대로 구현한 버전입니다. X를 1씩 증가시키면서, Y에 기울기($0.4$)를 계속 더합니다. 오차가 **0.5(픽셀의 절반)**를 넘으면 Y를 한 칸 올립니다.

```c
// [버전 1] 실수 연산
float m = (float)dy / dx; // 0.4
float error = 0.0;        // 0에서 시작
int y = y0;

for (int x = x0; x < x1; x++) {
    plot(x, y);
    error += m;           // 오차 누적 (0.4 -> 0.8 -> 1.2 ...)

    // [판단 기준] 0.5 (절반)
    if (error >= 0.5) {
        y++;              // Y 한 칸 이동
        error -= 1.0;     // 1.0 깎기
    }
}
```

- **문제점:** `float` 연산과 나눗셈이 있어 GBA에서 매우 느립니다.

---

#### 2단계: 정수 변환 버전 (Integer Scaled)

**"나눗셈을 없애기 위해 $dx$를 곱한 방법"**

1단계 식의 양변에 **$dx$**를 곱해버립니다.

- $m(dy/dx) \times dx \rightarrow \mathbf{dy}$

- $0.5 \times dx \rightarrow \mathbf{dx / 2}$

- $1.0 \times dx \rightarrow \mathbf{dx}$

이제 비교 기준이 $0.5$가 아니라 **$dx/2$**가 됩니다.

```c
// [버전 2] 정수 연산 (나눗셈 제거)
int error = 0;           // 0 * dx = 0
int y = y0;

for (int x = x0; x < x1; x++) {
    plot(x, y);
    error += dy;         // m 대신 dy를 더함

    // [판단 기준] dx / 2 (0.5 * dx)
    if (error >= (dx / 2)) { 
        y++;
        error -= dx;     // 1.0 대신 dx를 뺌
    }
}
```

- **발전:** `float`가 사라졌습니다!

- **문제점:**
  
  1. `dx / 2` 계산 시 $dx$가 홀수면 **0.5가 버림**당해 오차가 생깁니다.
  
  2. 여전히 "X축 기준 루프"라, 가파른 선($dy > dx$)을 그리려면 `if-else`로 코드를 따로 짜야 합니다. (변수 스와핑 필요)



#### 3단계: 최종 진화 (Alois Zingl Version)

### 🧬 진화 1단계: "곱하기 2" (반올림 문제 해결)

**목표:** 느린 실수(`float`)와 나눗셈을 없애고, **순수 정수(int)**로만 만들자.

#### 1. 문제 상황 (실수 연산)

기울기가 $0.4$ ($dx=10, dy=4$)인 선을 그릴 때, 우리는 오차(error)가 **0.5**를 넘는지 감시해야 합니다.

- `error += 0.4`

- `if (error >= 0.5)` $\rightarrow$ Y 증가

#### 2. 1차 시도 (dx 곱하기)

양변에 $dx(10)$를 곱해서 소수점($0.4$)을 없앱니다.

- `error += 4` (즉, $dy$)

- `if (error >= 5)` (즉, $0.5 \times 10 = 5$)

하지만 $dx$가 홀수(예: 11)라면? $11 \times 0.5 = 5.5$가 되어버립니다. 정수형 변수(`int`)에서는 $0.5$가 잘려나가 **오차**가 발생합니다.

#### 3. 해결책 (2 곱하기)

그래서 **처음부터 모든 수식에 2를 곱해버립니다.** 그러면 $0.5$ 같은 건 절대 나올 수가 없습니다.

- 더하는 값: $dy \rightarrow \mathbf{2dy}$

- 비교 기준: $0.5 \times dx \rightarrow \mathbf{dx}$ ($0.5 \times dx \times 2 = dx$)

**[결과 코드: 정수형 브레즌햄]**

이 단계까지 오면, 코드는 이렇게 생겼습니다. (아직 X축/Y축 로직이 분리된 상태)

```c
// 진화 1단계 결과물 (정수화 완료, 하지만 루프는 분리됨)
int err = 0;
int dy2 = 2 * dy;
int dx2 = 2 * dx;

if (dx > dy) { 
    // [X축 기준 루프] (가로로 긴 경우)
    for (x = x0; x < x1; x++) {
        plot(x, y);
        err += dy2;      // 2*dy 더함
        if (err > dx) {  // 기준이 dx가 됨 (2*0.5*dx)
            y++;
            err -= dx2;  // 2*dx 뺌
        }
    }
} else {
    // [Y축 기준 루프] (세로로 긴 경우) -> 코드를 또 짜야 함!
    // ...
}
```

---

### 🧬 진화 2단계: "로직 통합" (X/Y 루프 합치기)

**목표:** `if (dx > dy)`로 나누어 코드를 두 번 짜는 게 싫다. **하나의 루프**로 만들자.

#### 1. 발상의 전환 (Alois Zingl 방식)

기존 방식은 "X는 무조건 가고, Y는 상황 봐서 간다"였습니다.

통합 방식은 **"매 턴마다 X가 갈지, Y가 갈지 공평하게 심사하자"**는 것입니다.

#### 2. 에러 값의 재정의 (`dx - dy`)

이제 `err`는 단순한 오차가 아니라 **"균형(Balance)"**을 의미합니다.

- `dx`(가로 힘)가 크면 `err`는 양수(+) $\rightarrow$ X축 이동 유도

- `dy`(세로 힘)가 크면 `err`는 음수(-) $\rightarrow$ Y축 이동 유도

그래서 초기값을 `err = dx - dy`로 설정하여, 선의 모양(가로형/세로형)에 따른 **초기 성향**을 입력해줍니다.

#### 3. 통합 루프의 탄생

이제 "X 루프"와 "Y 루프"를 합칩니다.

- **X 이동 조건:** `err`가 너무 작아지지 않았으면(Y쪽으로 안 쏠렸으면) $\rightarrow$ X 이동, `err`에서 $dy$ 뺌.

- **Y 이동 조건:** `err`가 너무 커지지 않았으면(X쪽으로 안 쏠렸으면) $\rightarrow$ Y 이동, `err`에 $dx$ 더함.

이때, **1단계에서 만든 "2배 뻥튀기" 논리**를 여기에 적용합니다.

**[결과 코드: 통합 브레즌햄]**

```c
// 진화 2단계 결과물 (정수화 + 통합 루프)
int err = dx - dy; // 균형 초기화

while(1) {
    plot(x0, y0);
    if (x0 == x1 && y0 == y1) break;

    int e2 = 2 * err; // 1단계의 '2배 뻥튀기' 적용 (반올림 방지)

    // Y 이동 성향이 너무 강하지 않으면 -> X 이동
    if (e2 > -dy) { 
        err -= dy; 
        x0 += sx; 
    }

    // X 이동 성향이 너무 강하지 않으면 -> Y 이동
    if (e2 < dx) { 
        err += dx; 
        y0 += sy; 
    }
}
```

---

### 💡 요약: 비약 없는 연결

1. **진화 1 (Math):** $0.5$ 비교를 피하기 위해 **비교 기준을 2배**($dx$)로 키웠습니다. 그래서 코드에 `2 * err`가 등장합니다.

2. **진화 2 (Logic):** 가로/세로 루프를 합치기 위해, `err`를 **$dx$와 $dy$의 차이(균형)**로 재정의했습니다. 그래서 초기값이 `dx - dy`가 됩니다.
