### 🧬 브레즌햄 알고리즘의 3단계 진화

가정: $(0,0)$에서 $(10, 4)$로 선을 긋습니다. ($dx=10, dy=4$)

기울기 $m = 0.4$ 입니다.

#### 1단계: 원시 버전 (Floating Point)

**"가장 직관적이지만 느린 방법"**

수학 교과서 그대로 구현한 버전입니다. X를 1씩 증가시키면서, Y에 기울기($0.4$)를 계속 더합니다. 오차가 **0.5(픽셀의 절반)** 를 넘으면 Y를 한 칸 올립니다.

```c
// [버전 1] 실수 연산
float m = (float)dy / dx; // 0.4
float error = 0.0;        // 0에서 시작
int y = y0;

for (int x = x0; x < x1; x++) {
    plot(x, y);
    error += m;           // 오차 누적 (0.4 -> 0.8 -> 1.2 ...)

    // [판단 기준] 0.5 (절반)
    if (error >= 0.5) {
        y++;              // Y 한 칸 이동
        error -= 1.0;     // 1.0 깎기
    }
}
```

- **문제점:** `float` 연산과 나눗셈이 있어 GBA에서 매우 느립니다.

---

#### 2단계: 정수 변환 버전 (Integer Scaled)

**"나눗셈을 없애기 위해 $dx$를 곱한 방법"**

1단계 식의 양변에 **$dx$** 를 곱해버립니다.

- $m(dy/dx) \times dx \rightarrow \mathbf{dy}$

- $0.5 \times dx \rightarrow \mathbf{dx / 2}$

- $1.0 \times dx \rightarrow \mathbf{dx}$

이제 비교 기준이 $0.5$가 아니라 **$dx/2$** 가 됩니다.

```c
// [버전 2] 정수 연산 (나눗셈 제거)
int error = 0;           // 0 * dx = 0
int y = y0;

for (int x = x0; x < x1; x++) {
    plot(x, y);
    error += dy;         // m 대신 dy를 더함

    // [판단 기준] dx / 2 (0.5 * dx)
    if (error >= (dx / 2)) { 
        y++;
        error -= dx;     // 1.0 대신 dx를 뺌
    }
}
```

- **발전:** `float`가 사라졌습니다!

- **문제점:**
  
  1. `dx / 2` 계산 시 $dx$가 홀수면 **0.5가 버림**당해 오차가 생깁니다.
  
  2. 여전히 "X축 기준 루프"라, 가파른 선($dy > dx$)을 그리려면 `if-else`로 코드를 따로 짜야 합니다. (변수 스와핑 필요)

#### 3단계: 최종 진화 (Alois Zingl Version)

### 🧬 진화 1단계: "곱하기 2" (반올림 문제 해결)

**목표:** 느린 실수(`float`)와 나눗셈을 없애고, **순수 정수(int)** 로만 만들자.

#### 1. 문제 상황 (실수 연산)

기울기가 $0.4$ ($dx=10, dy=4$)인 선을 그릴 때, 우리는 오차(error)가 **0.5**를 넘는지 감시해야 합니다.

- `error += 0.4`

- `if (error >= 0.5)` $\rightarrow$ Y 증가

#### 2. 1차 시도 (dx 곱하기)

양변에 $dx(10)$를 곱해서 소수점($0.4$)을 없앱니다.

- `error += 4` (즉, $dy$)

- `if (error >= 5)` (즉, $0.5 \times 10 = 5$)

하지만 $dx$가 홀수(예: 11)라면? $11 \times 0.5 = 5.5$가 되어버립니다. 정수형 변수(`int`)에서는 $0.5$가 잘려나가 **오차**가 발생합니다.

#### 3. 해결책 (2 곱하기)

그래서 **처음부터 모든 수식에 2를 곱해버립니다.** 그러면 $0.5$ 같은 건 절대 나올 수가 없습니다.

- 더하는 값: $dy \rightarrow \mathbf{2dy}$

- 비교 기준: $0.5 \times dx \rightarrow \mathbf{dx}$ ($0.5 \times dx \times 2 = dx$)

**[결과 코드: 정수형 브레즌햄]**

이 단계까지 오면, 코드는 이렇게 생겼습니다. (아직 X축/Y축 로직이 분리된 상태)

```c
// 진화 1단계 결과물 (정수화 완료, 하지만 루프는 분리됨)
int err = 0;
int dy2 = 2 * dy;
int dx2 = 2 * dx;

if (dx > dy) { 
    // [X축 기준 루프] (가로로 긴 경우)
    for (x = x0; x < x1; x++) {
        plot(x, y);
        err += dy2;      // 2*dy 더함
        if (err > dx) {  // 기준이 dx가 됨 (2*0.5*dx)
            y++;
            err -= dx2;  // 2*dx 뺌
        }
    }
} else {
    // [Y축 기준 루프] (세로로 긴 경우) -> 코드를 또 짜야 함!
    // ...
}
```

---

### 🧬 진화 2단계: "로직 통합" (X/Y 루프 합치기)

**목표:** `if (dx > dy)`로 나누어 코드를 두 번 짜는 게 싫다. **하나의 루프**로 만들자.

#### 1. 발상의 전환 (Alois Zingl 방식)

기존 방식은 "X는 무조건 가고, Y는 상황 봐서 간다"였습니다.

통합 방식은 **"매 턴마다 X가 갈지, Y가 갈지 공평하게 심사하자"** 는 것입니다.

#### 2. 에러 값의 재정의 (`dx - dy`)

이제 `err`는 단순한 오차가 아니라 **"균형(Balance)"** 을 의미합니다.

- `dx`(가로 힘)가 크면 `err`는 양수(+) $\rightarrow$ X축 이동 유도

- `dy`(세로 힘)가 크면 `err`는 음수(-) $\rightarrow$ Y축 이동 유도

그래서 초기값을 `err = dx - dy`로 설정하여, 선의 모양(가로형/세로형)에 따른 **초기 성향**을 입력해줍니다.

#### 3. 통합 루프의 탄생

이제 "X 루프"와 "Y 루프"를 합칩니다.

- **X 이동 조건:** `err`가 너무 작아지지 않았으면(Y쪽으로 안 쏠렸으면) $\rightarrow$ X 이동, `err`에서 $dy$ 뺌.

- **Y 이동 조건:** `err`가 너무 커지지 않았으면(X쪽으로 안 쏠렸으면) $\rightarrow$ Y 이동, `err`에 $dx$ 더함.

이때, **1단계에서 만든 "2배 뻥튀기" 논리**를 여기에 적용합니다.

**[결과 코드: 통합 브레즌햄]**

```c
// 진화 2단계 결과물 (정수화 + 통합 루프)
int err = dx - dy; // 균형 초기화

while(1) {
    plot(x0, y0);
    if (x0 == x1 && y0 == y1) break;

    int e2 = 2 * err; // 1단계의 '2배 뻥튀기' 적용 (반올림 방지)

    // Y 이동 성향이 너무 강하지 않으면 -> X 이동
    if (e2 > -dy) { 
        err -= dy; 
        x0 += sx; 
    }

    // X 이동 성향이 너무 강하지 않으면 -> Y 이동
    if (e2 < dx) { 
        err += dx; 
        y0 += sy; 
    }
}
```

---

### 💡 요약: 비약 없는 연결

1. **진화 1 (Math):** $0.5$ 비교를 피하기 위해 **비교 기준을 2배**($dx$)로 키웠습니다. 그래서 코드에 `2 * err`가 등장합니다.

2. **진화 2 (Logic):** 가로/세로 루프를 합치기 위해, `err`를 **$dx$와 $dy$의 차이(균형)** 로 재정의했습니다. 그래서 초기값이 `dx - dy`가 됩니다.

추상적인 표현을 걷어내고, 오직 **수식과 논리**로만 설명해 드리겠습니다.

태경 님이 헷갈리셨던 핵심 질문:

> "오차는 0.5랑 비교해야 하는데, 2를 곱했으면 1이랑 비교해야지, **왜 하필 $-dy$랑 $dx$인가?**"

**정답:**

우리가 비교해야 하는 **"0.5"라는 기준값 자체가 $dy$와 $dx$에 비례해서 커졌기 때문**입니다.

단순히 상수 1이 되는 것이 아닙니다.

그 수학적 유도 과정을 단계별로 보여드립니다.

---

### 1. 기준값의 변화 (수식 증명)

우리가 선을 그릴 때 판단해야 할 것은 **"선의 실제 위치가 픽셀의 경계선($\pm 0.5$)을 넘었는가?"**입니다.

이 경계선 값($\pm 0.5$)이 수식 변환 과정에서 어떻게 변하는지 보세요.

#### **[단계 1] 원래 기준: 0.5**

- 판단 기준: 오차(Error) < **0.5** (픽셀의 절반)

#### **[단계 2] 정수 변환 1차 (양변에 분모 곱하기)**

나눗셈을 없애기 위해 식 전체에 **기울기의 분모($dx$ 또는 $dy$)**를 곱합니다.

이때 "기준값 0.5"도 곱해집니다.

- **X축 이동 시 오차 변화량:** $dy$ (기울기 $\frac{dy}{dx}$에서 분모 $dx$를 곱함)

- **Y축 이동 시 오차 변화량:** $dx$ (기울기 $\frac{dx}{dy}$에서 분모 $dy$를 곱함)

이 과정에서 **"0.5 (반 픽셀)"**라는 물리적 거리는, 오차 누적 시스템 안에서 다음과 같은 값으로 변환됩니다.

- **X축 방향의 반 픽셀 값:** $0.5 \times dy$

- **Y축 방향의 반 픽셀 값:** $0.5 \times dx$

> **잠깐! 왜 여기서 $dy, dx$가 튀어나오죠?**
> 
> 기울기가 가파를수록($dy$가 클수록) X축으로 1칸 갔을 때 오차가 확 커지죠?
> 
> 그래서 **"X축으로 반 칸(0.5) 갔을 때의 오차"**는 $0.5 \times dy$가 됩니다.
> 
> 마찬가지로 **"Y축으로 반 칸(0.5) 갔을 때의 오차"**는 $0.5 \times dx$가 됩니다.

#### **[단계 3] 정수 변환 2차 (양변에 2 곱하기)**

소수점($0.5$)을 없애기 위해 2를 곱합니다.

- X축 기준값: $(0.5 \times dy) \times 2 = \mathbf{dy}$

- Y축 기준값: $(0.5 \times dx) \times 2 = \mathbf{dx}$

**결론:**

우리가 코드에서 비교하는 **$-dy$와 $dx$**는 임의의 변수가 아니라, **"픽셀의 경계선(0.5)"이 수식 변환을 거쳐 정수로 재탄생한 값**입니다.

---

### 2. 조건식의 기계적 해석

이제 감성적인 설명 대신, 기계적인 논리로 코드를 분석해 봅시다.

`err` 변수는 **현재 좌표와 이상적인 선 사이의 거리(오차)**입니다.

#### **(1) `if (e2 > -dy)` : X축 이동 조건**

- **목적:** "지금 오차가 **X축 이동 허용 범위(아래쪽 경계)** 안에 있는가?"

- **수식 복원:**
  
  $$2 \times \text{err} > -dy$$
  
  $$\text{err} > -0.5 \times dy$$

- **의미:** 현재 오차가 **"X축 방향으로 반 칸(-0.5) 이동했을 때의 오차값($-0.5 dy$)"**보다 커야 한다.

- **해석:** 만약 이 조건이 거짓(`false`)이라면, 오차가 $-0.5 dy$보다 더 작다는 뜻입니다. 즉, 선이 픽셀의 아래쪽 경계선($-0.5$)을 뚫고 내려갔으므로 **X축으로 더 이상 이동하면 안 되고 Y축으로 이동해서 보정해야 함**을 의미합니다.

#### **(2) `if (e2 < dx)` : Y축 이동 조건**

- **목적:** "지금 오차가 **Y축 이동 허용 범위(오른쪽 경계)** 안에 있는가?"

- **수식 복원:**
  
  $$2 \times \text{err} < dx$$
  
  $$\text{err} < 0.5 \times dx$$

- **의미:** 현재 오차가 **"Y축 방향으로 반 칸(0.5) 이동했을 때의 오차값($0.5 dx$)"**보다 작아야 한다.

- **해석:** 만약 이 조건이 거짓(`false`)이라면, 오차가 $0.5 dx$보다 더 크다는 뜻입니다. 즉, 선이 픽셀의 오른쪽 경계선($+0.5$)을 뚫고 나갔으므로 **Y축으로 더 이상 이동하면 안 되고 X축으로 이동해서 보정해야 함**을 의미합니다.

### 📝 최종 요약

1. **왜 1이 아닌가?**
   
   - 식 전체에 $dx, dy$를 곱해서 스케일을 키웠기 때문에, 기준값인 0.5도 같이 커져서 $0.5 dx$ 혹은 $0.5 dy$가 되었습니다.

2. **왜 -dy, dx인가?**
   
   - 여기에 2를 곱해서 소수를 없앴기 때문에 최종적으로 $dy$와 $dx$가 된 것입니다.
   
   - 부호(-)는 알고리즘 내에서 X축 이동이 오차를 감소시키는 방향(`err -= dy`)이기 때문입니다.

숫자를 직접 대입해서 **시뮬레이션(Trace)** 해보면 아주 명확해질 것입니다.

**설정 (Setup)**

- **목표:** $(0,0)$ 에서 $(10, 4)$ 까지 선 긋기

- **변수:**
  
  - $dx = 10$
  
  - $dy = 4$
  
  - $sx = 1$ (X 증가 방향), $sy = 1$ (Y 증가 방향)
  
  - **비교 기준값:**
    
    - X 이동 조건: `e2 > -4` ($-dy$)
    
    - Y 이동 조건: `e2 < 10` ($dx$)

- **초기 오차:** `err = dx - dy` = $10 - 4 = \mathbf{6}$

이제 루프를 하나씩 돌려봅시다.

---

### 🏁 시작: 좌표 (0, 0), 현재 err = 6

#### [Loop 1]

1. **점 찍기:** $(0, 0)$에 점을 찍습니다.

2. **스냅샷 (`e2`):** $2 \times 6 = \mathbf{12}$

3. **X 이동 심사 (`e2 > -4`?):**
   
   - $12 > -4$ (**참**) $\rightarrow$ X 이동!
   
   - $x$는 $1$이 됩니다.
   
   - `err` 갱신: $6 - 4 = \mathbf{2}$ (균형이 Y쪽으로 조금 기울어짐)

4. **Y 이동 심사 (`e2 < 10`?):**
   
   - $12 < 10$ (**거짓**) $\rightarrow$ 이동 안 함.

5. **결과:** 좌표 $(1, 0)$, `err` = $2$

---

#### [Loop 2]

1. **점 찍기:** $(1, 0)$에 점을 찍습니다.

2. **스냅샷 (`e2`):** $2 \times 2 = \mathbf{4}$

3. **X 이동 심사 (`4 > -4`?):**
   
   - **참** $\rightarrow$ X 이동!
   
   - $x$는 $2$가 됩니다.
   
   - `err` 갱신: $2 - 4 = \mathbf{-2}$ (균형이 음수가 됨 -> Y쪽으로 많이 기울어짐!)

4. **Y 이동 심사 (`4 < 10`?):**
   
   - **참** $\rightarrow$ Y 이동!
   
   - $y$는 $1$이 됩니다.
   
   - `err` 갱신: $-2 + 10 = \mathbf{8}$ (Y 이동했으니 다시 X쪽으로 균형 회복)

5. **결과:** 좌표 $(2, 1)$, `err` = $8$
   
   - *(특이점: X와 Y가 동시에 변해서 대각선 이동을 했습니다)*

---

#### [Loop 3]

1. **점 찍기:** $(2, 1)$에 점을 찍습니다.

2. **스냅샷 (`e2`):** $2 \times 8 = \mathbf{16}$

3. **X 이동 심사 (`16 > -4`?):**
   
   - **참** $\rightarrow$ X 이동!
   
   - $x$는 $3$이 됩니다.
   
   - `err` 갱신: $8 - 4 = \mathbf{4}$

4. **Y 이동 심사 (`16 < 10`?):**
   
   - **거짓** $\rightarrow$ 이동 안 함.

5. **결과:** 좌표 $(3, 1)$, `err` = $4$

---

#### [Loop 4]

1. **점 찍기:** $(3, 1)$에 점을 찍습니다.

2. **스냅샷 (`e2`):** $2 \times 4 = \mathbf{8}$

3. **X 이동 심사 (`8 > -4`?):**
   
   - **참** $\rightarrow$ X 이동!
   
   - $x$는 $4$가 됩니다.
   
   - `err` 갱신: $4 - 4 = \mathbf{0}$ (완벽한 균형! 선의 정중앙에 위치)

4. **Y 이동 심사 (`8 < 10`?):**
   
   - **참** $\rightarrow$ Y 이동!
   
   - $y$는 $2$가 됩니다.
   
   - `err` 갱신: $0 + 10 = \mathbf{10}$ (다시 균형 회복)

5. **결과:** 좌표 $(4, 2)$, `err` = $10$
   
   - *(또 대각선 이동 발생)*

---

#### [Loop 5] (패턴 반복의 시작)

1. **점 찍기:** $(4, 2)$에 점을 찍습니다.

2. **스냅샷 (`e2`):** $2 \times 10 = \mathbf{20}$

3. **X 이동 심사 (`20 > -4`?):**
   
   - **참** $\rightarrow$ X 이동!
   
   - $x$는 $5$가 됩니다.
   
   - `err` 갱신: $10 - 4 = \mathbf{6}$

4. **Y 이동 심사 (`20 < 10`?):**
   
   - **거짓** $\rightarrow$ 이동 안 함.

5. **결과:** 좌표 $(5, 2)$, `err` = $6$
   
   - **주목:** 시작할 때(Loop 1) `err`가 6이었죠? 정확히 5칸 오니까 패턴이 리셋되었습니다. ($10:4 = 5:2$ 비율이니까요!)

---

### 📊 시각적 요약 (Pixel Grid)

이 과정을 픽셀 그리드에서 보면 이렇습니다.

Plaintext

```
(y)
4 |                      (도착)
3 |                  ■ .
2 |          ■ . ■ .
1 |      ■ .
0 |  ■ .
   -------------------------- (x)
     0   1   2   3   4   5 ...
```

- **Loop 1:** (0,0) $\rightarrow$ 그냥 옆으로 (1,0)

- **Loop 2:** (1,0) $\rightarrow$ 대각선으로 (2,1) (**Y 이동 발생!**)

- **Loop 3:** (2,1) $\rightarrow$ 그냥 옆으로 (3,1)

- **Loop 4:** (3,1) $\rightarrow$ 대각선으로 (4,2) (**Y 이동 발생!**)

**핵심 포인트:**

Loop 2에서 `e2`는 **4**였습니다.

- `4 > -4` (X 갈 수 있어?) $\rightarrow$ 응.

- `4 < 10` (Y 갈 수 있어?) $\rightarrow$ 응.

- **그래서 둘 다 이동(대각선)이 일어난 것입니다.**
