`volatile` 키워드는 **"컴파일러야, 제발 똑똑한 척하지 말고 시키는 대로 해!"**라고 명령하는 것입니다.

임베디드 프로그래밍(GBA)에서 `volatile`은 선택이 아니라 **생존 필수품**입니다. 왜 그런지 컴파일러의 입장과 하드웨어의 입장에서 설명해 드릴게요.

---

### 1. 컴파일러의 "똑똑한 척" (최적화)

컴파일러는 코드를 더 빠르게 만들기 위해 불필요해 보이는 작업을 삭제(최적화)하려는 습성이 있습니다.

**`volatile`이 없을 때 벌어지는 일 (가정):**

C

```
// VRAM[0] 위치에 빨간색을 찍었다가, 바로 파란색으로 바꾸고 싶음
*address = RED;   // (1)
*address = BLUE;  // (2)
```

- **컴파일러의 생각:** "어라? `address` 변수에 RED를 넣고 아무것도 안 하고 바로 BLUE를 넣네? 그럼 (1)번 줄은 쓸모없잖아? 삭제!"

- **결과:** 화면에 빨간색은 아예 나타나지도 않고 바로 파란색만 뜹니다.

### 2. 하드웨어의 "변덕" (외부 변화)

컴파일러는 코드가 실행되는 동안 변수 값이 오직 **내 코드에 의해서만** 바뀐다고 믿습니다. 하지만 하드웨어 레지스터는 내 코드가 건드리지 않아도 제멋대로 바뀝니다.

**`volatile`이 없을 때 벌어지는 일 (무한 루프):**

C

```
// VCount(스캔라인)가 160이 될 때까지 기다리기
while (*vcount_reg < 160) {
    // 아무것도 안 함
}
```

- **컴파일러의 생각:** "`while` 루프 안에서 `vcount_reg` 값을 바꾸는 코드가 없네? 그럼 이 값은 영원히 안 변하겠지? 매번 메모리 읽어오는 건 낭비니까, 처음에 한 번만 읽어서 레지스터(캐시)에 저장해두고 그것만 계속 비교해야지."

- **실제 동작 코드 (최적화 후):**
  
  C
  
  ```
  int temp = *vcount_reg; // 100이라고 가정
  while (temp < 160);     // 100 < 160은 참이므로 무한 루프 발생!
  ```

- **결과:** GBA는 스캔라인이 계속 바뀌고 있는데, 프로그램은 혼자서 옛날 값만 쳐다보며 영원히 멈춰버립니다(Hang).

---

### 3. `volatile`의 역할: "항상 메모리를 확인해라"

`volatile`을 붙이면 컴파일러에게 다음과 같이 강력하게 경고합니다.

1. **캐싱 금지 (No Caching):** "이 값은 언제 어디서 바뀔지 모른다. CPU 레지스터에 저장해두지 말고, **매번 실제 메모리 주소(`0x06000000`)에 가서 새로 읽어와라.**"

2. **순서 변경 금지 (No Reordering):** "내가 쓴 순서대로 정확하게 쓰고 읽어라. 최적화한답시고 순서를 바꾸거나 생략하지 마라."

### 📚 소스 코드에서의 증거

`input_test.c` 파일의 주석에도 이 내용이 정확히 명시되어 있습니다.

> `volatile 키워드 필수: 하드웨어에 의해 값이 언제든 바뀔 수 있으므로, 컴파일러가 최적화(캐싱)하지 않고 매번 메모리 주소에서 직접 읽도록 강제함.`

**결론:** GBA의 VRAM, 레지스터, 키 입력 등 **하드웨어와 직접 연결된 모든 주소**에는 반드시 `volatile`이 붙어야 합니다. 그렇지 않으면 내 의도와 다르게 동작하거나 게임이 멈춥니다.
