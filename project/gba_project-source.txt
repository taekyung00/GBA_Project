Directory: project
Files analyzed: 2

Estimated tokens: 2.8k

Directory structure:
└── project/
    └── include/
        ├── fixed.h
        └── gba.h


================================================
FILE: include/fixed.h
================================================
#ifndef FIXED_H
#define FIXED_H

#include "gba.h" // u32, bool 등 기본 타입 사용을 위해 포함

// =========================================================================
// 💡 고정 소수점(Fixed Point) 라이브러리 (Q24.8 Format)
// -------------------------------------------------------------------------
//
// [1. 왜 사용하는가?]
//    GBA(ARM7TDMI)에는 실수(float)를 계산하는 하드웨어(FPU)가 없습니다.
//    float를 쓰면 소프트웨어적으로 에뮬레이션하느라 속도가 수십 배 느려집니다.
//    따라서 "256을 곱한 정수"를 사용하여 소수점 연산을 흉내 냅니다.
//
// [2. 하드웨어의 관점 (Hardware Agnostic)]
//    GBA 하드웨어(CPU, PPU)는 이 값이 고정 소수점인지 모릅니다.
//    그냥 '256배 큰 정수'로 취급하여 덧셈/뺄셈을 수행합니다.
//    우리가 화면(VRAM/OAM)에 값을 넘길 때만 '정수'로 통역해주면 됩니다.
//
// [3. 사용 원칙 (The Two Worlds)]
//    - 물리 세계 (Physics): 위치(x,y), 속도, 중력 등 움직이는 값 -> 무조건 'fixed' 유지
//    - 논리 세계 (Logic): 아이템 개수, 인덱스, 타일 번호 -> 일반 'int' 사용
//    - 렌더링 (Render): 그리기 직전에 'fixed' -> 'int'로 변환하여 하드웨어에 전달
//
// =========================================================================


// -------------------------------------------------------------------------
// 1. 설정 상수 (Configuration)
// -------------------------------------------------------------------------
#define FIX_SHIFT    8                // 하위 8비트를 소수부로 사용
#define FIX_SCALE    (1 << FIX_SHIFT) // 256 (1.0을 의미하는 정수 값)
#define FIX_MASK     (FIX_SCALE - 1)  // 0xFF (소수부 비트 마스크)
#define FIX_ONE      FIX_SCALE        // 1.0


// -------------------------------------------------------------------------
// 2. 자료형 정의 (Typedef)
// -------------------------------------------------------------------------
// int와 같지만, "이 변수는 256배 튀겨진 값이다"라고 명시하기 위해 사용합니다.
typedef int fixed;


// -------------------------------------------------------------------------
// 3. 변환 매크로 (Conversion Macros)
// -------------------------------------------------------------------------

// [정수 -> 고정 소수점] (Enter Physics World)
// 사용: 초기값 설정, 정수 더하기
// 예: INT_TO_FIX(10) -> 2560
#define INT_TO_FIX(n)    ((fixed)((n) << FIX_SHIFT))

// [실수 -> 고정 소수점] (Data Import)
// 사용: 물리 상수 초기화 (예: 중력 9.8, 마찰력 0.1)
// 주의: float 연산이 포함되므로 '초기화 단계'에서만 사용할 것. 루프 내부 금지.
#define FLOAT_TO_FIX(f)  ((fixed)((f) * (float)FIX_SCALE))

// [고정 소수점 -> 정수 (버림)] (Render to Hardware)
// 사용: 최종적으로 화면(VRAM)에 좌표를 찍을 때
// 예: 2560(10.0) -> 10, 2688(10.5) -> 10
#define FIX_TO_INT(n)    ((n) >> FIX_SHIFT)

// [고정 소수점 -> 정수 (반올림)] (Render Precise)
// 사용: 더 정확한 좌표가 필요할 때
// 예: 10.5 -> 11, 10.4 -> 10
#define FIX_ROUND(n)     (((n) + (FIX_SCALE / 2)) >> FIX_SHIFT)

// [고정 소수점 -> 실수] (Debugging)
// 사용: printf 등으로 값을 확인하고 싶을 때
// 주의: 절대 게임 로직이나 연산용으로 사용하지 말 것 (매우 느림).
#define FIX_TO_FLOAT(n)  ((float)(n) / (float)FIX_SCALE)


// -------------------------------------------------------------------------
// 4. 산술 연산 함수 (Arithmetic Functions)
// -------------------------------------------------------------------------

// [덧셈/뺄셈]
// 그냥 + - 연산자를 사용하면 됩니다. (비트 이동 필요 없음)
// fixed c = a + b;


// [곱셈]
// 원리: (A * 256) * (B * 256) = (A * B) * 65536
// 결과가 256^2배가 되므로, 다시 256(SHIFT)으로 나눠줘야 원래 스케일로 돌아옴.
// (long long) 캐스팅: 32비트끼리 곱하면 오버플로우가 발생할 수 있어 64비트로 확장.
static inline fixed fix_mul(fixed a, fixed b) {
    return (fixed)(((long long)a * b) >> FIX_SHIFT);
}

// [나눗셈]
// 원리: (A * 256) / (B * 256) = A / B (스케일 소실됨)
// 미리 A에 256을 한번 더 곱해놓고 나눠야 스케일(256배)이 유지됨.
static inline fixed fix_div(fixed a, fixed b) {
    return (fixed)(((long long)a << FIX_SHIFT) / b);
}

// [절댓값]
static inline fixed fix_abs(fixed a) {
    return (a < 0) ? -a : a;
}

// [최소값]
static inline fixed fix_min(fixed a, fixed b) {
    return (a < b) ? a : b;
}

// [최대값]
static inline fixed fix_max(fixed a, fixed b) {
    return (a > b) ? a : b;
}

#endif // FIXED_H


================================================
FILE: include/gba.h
================================================
#ifndef GBA_H
#define GBA_H

// =========================================================================
// 1. 기본 자료형 (Primitive Types)
// -------------------------------------------------------------------------
// GBA(ARM7TDMI)는 32비트 RISC CPU입니다.
// C언어의 'int' 크기는 컴파일러마다 다를 수 있으므로, 
// 하드웨어 비트 수에 딱 맞는 명시적인 타입을 사용하는 것이 표준입니다.
// =========================================================================

#include <stdbool.h> // 표준 bool, true, false 사용 (C99/C23 호환)
#include <stddef.h>  // 표준 NULL 사용

typedef unsigned char  u8;  // 8비트 (1바이트): 타일 인덱스, 작은 정수 등
typedef unsigned short u16; // 16비트 (2바이트): 색상(RGB555), 레지스터 제어 등 주력 타입
typedef unsigned int   u32; // 32비트 (4바이트): 메모리 주소, 큰 데이터, DMA 전송 시 사용


// =========================================================================
// 2. 메모리 맵 (Memory Map)
// -------------------------------------------------------------------------
// GBA는 OS가 없습니다. 특정 메모리 주소에 값을 쓰면 하드웨어가 즉시 반응합니다.
// 이를 Memory Mapped I/O (MMIO)라고 합니다.
// =========================================================================

#define REG_BASE        0x04000000 // I/O 레지스터들의 시작 주소
#define VRAM_BASE       0x06000000 // 비디오 메모리(화면 데이터) 시작 주소

// VRAM 포인터
// u16 포인터인 이유: VRAM은 보통 16비트(색상 값) 단위로 읽고 쓰기 때문입니다.
// volatile 필수: 컴파일러가 "아까 썼으니까 안 써도 되겠지?"라고 최적화하는 것을 막습니다.
#define VRAM            ((volatile u16*)VRAM_BASE)

// =========================================================================
// 3. 하드웨어 레지스터 (Hardware Registers)
// -------------------------------------------------------------------------
// 주소 앞에 *(volatile 타입 *)을 붙이는 이유:
// 1. (volatile 타입 *): 정수 숫자를 '포인터(주소)'로 취급해라.
// 2. *: 그 포인터가 가리키는 실제 '값'을 가져오거나 수정해라 (Dereference).
// =========================================================================

// [디스플레이 제어]
// 주소: 0x04000000
// 타입: u32 (본래 u16이지만, 32비트 버스 효율을 위해 u32로 접근하기도 함)
// 역할: 화면 모드(0~5), 배경 활성화, 스프라이트 활성화 등 총괄 설정
#define REG_DISPCNT     (*(volatile u32*)(REG_BASE + 0x0000))

// [수직 라인 카운터 (Scanline Counter)]
// 주소: 0x04000006
// 타입: u16 (0~227 범위)
// 역할: 현재 전자총이 그리고 있는 가로줄 번호를 읽음 (Read-Only). VSync 구현의 핵심.
#define REG_VCOUNT      (*(volatile u16*)(REG_BASE + 0x0006))

// [키 입력 상태]
// 주소: 0x04000130
// 타입: u16 (총 10개 버튼이므로 10비트 사용)
// 역할: 버튼이 눌렸는지 확인. (주의: 눌리면 0, 안 눌리면 1 -> Active Low)
#define REG_KEYINPUT    (*(volatile u16*)(REG_BASE + 0x0130))

// =========================================================================
// 4. 설정 상수 (Configuration Constants)
// =========================================================================

// 화면 크기 (물리적 해상도 고정)
#define SCREEN_W        240
#define SCREEN_H        160

// 디스플레이 모드 설정 비트
// REG_DISPCNT에 OR(|) 연산으로 설정함
#define MODE_3          0x0003 // 비트맵 모드 (240x160, 트루컬러)
#define BG2_ENABLE      0x0400 // 배경 레이어 2 켜기 (Mode 3는 BG2를 사용함)

// =========================================================================
// 5. 색상 매크로 (Color Macros)
// -------------------------------------------------------------------------
// GBA는 15비트 색상(BGR555)을 사용합니다. 
// 포맷: XBBBBBGGGGGRRRRR (MSB 1비트는 사용 안 함)
// 각 채널 범위: 0 ~ 31
// =========================================================================

#define RGB(r, g, b)    ((u16)((r) | ((g) << 5) | ((b) << 10)))

#define COLOR_BLACK     RGB(0,  0,  0)
#define COLOR_WHITE     RGB(31, 31, 31)
#define COLOR_RED       RGB(31, 0,  0)
#define COLOR_GREEN     RGB(0,  31, 0)
#define COLOR_BLUE      RGB(0,  0,  31)
#define COLOR_GOLD      RGB(31, 25, 0)
#define COLOR_CYAN      RGB(0,  31, 31)
#define COLOR_MAGENTA   RGB(31, 0,  31)

// =========================================================================
// 6. 키 마스크 (Input Key Masks)
// -------------------------------------------------------------------------
// REG_KEYINPUT의 특정 비트만 쏙 뽑아내기 위한 필터(Mask)입니다.
// =========================================================================

#define KEY_A           0x0001 // 0번 비트
#define KEY_B           0x0002 // 1번 비트
#define KEY_SELECT      0x0004 // 2번 비트
#define KEY_START       0x0008 // 3번 비트
#define KEY_RIGHT       0x0010 // 4번 비트
#define KEY_LEFT        0x0020 // 5번 비트
#define KEY_UP          0x0040 // 6번 비트
#define KEY_DOWN        0x0080 // 7번 비트
#define KEY_R           0x0100 // 8번 비트
#define KEY_L           0x0200 // 9번 비트

// =========================================================================
// 7. 인라인 유틸리티 함수 (Inline Utilities)
// -------------------------------------------------------------------------
// 'static inline'을 쓰면 함수 호출 오버헤드 없이 코드가 그 자리에 복사됩니다.
// 헤더 파일에 구현할 때 가장 좋은 방법입니다.
// =========================================================================

// VSync 대기 함수
// 1. 현재 VBlank 중(화면 밖)이라면 다음 프레임까지 기다림 (REG_VCOUNT >= 160)
// 2. 화면을 그리는 중이라면, 다 그릴 때까지(160줄이 될 때까지) 기다림
static inline void sync_vblank() {
    while (REG_VCOUNT >= 160); // VBlank 중이면 대기
    while (REG_VCOUNT < 160);  // VDraw 중이면 대기
}

#endif

