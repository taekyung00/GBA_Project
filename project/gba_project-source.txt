Directory: project
Files analyzed: 3

Estimated tokens: 4.7k

Directory structure:
└── project/
    ├── include/
    │   ├── fixed.h
    │   └── gba.h
    └── sandbox/
        └── input_test.c


================================================
FILE: include/fixed.h
================================================
#ifndef FIXED_H
#define FIXED_H

#include "gba.h" // u32, bool 등 기본 타입 사용을 위해 포함

// =========================================================================
// 💡 고정 소수점(Fixed Point) 라이브러리 (Q24.8 Format)
// -------------------------------------------------------------------------
//
// [1. 왜 사용하는가?]
//    GBA(ARM7TDMI)에는 실수(float)를 계산하는 하드웨어(FPU)가 없습니다.
//    float를 쓰면 소프트웨어적으로 에뮬레이션하느라 속도가 수십 배 느려집니다.
//    따라서 "256을 곱한 정수"를 사용하여 소수점 연산을 흉내 냅니다.
//
// [2. 하드웨어의 관점 (Hardware Agnostic)]
//    GBA 하드웨어(CPU, PPU)는 이 값이 고정 소수점인지 모릅니다.
//    그냥 '256배 큰 정수'로 취급하여 덧셈/뺄셈을 수행합니다.
//    우리가 화면(VRAM/OAM)에 값을 넘길 때만 '정수'로 통역해주면 됩니다.
//
// [3. 사용 원칙 (The Two Worlds)]
//    - 물리 세계 (Physics): 위치(x,y), 속도, 중력 등 움직이는 값 -> 무조건 'fixed' 유지
//    - 논리 세계 (Logic): 아이템 개수, 인덱스, 타일 번호 -> 일반 'int' 사용
//    - 렌더링 (Render): 그리기 직전에 'fixed' -> 'int'로 변환하여 하드웨어에 전달
//
// =========================================================================


// -------------------------------------------------------------------------
// 1. 설정 상수 (Configuration)
// -------------------------------------------------------------------------
#define FIX_SHIFT    8                // 하위 8비트를 소수부로 사용
#define FIX_SCALE    (1 << FIX_SHIFT) // 256 (1.0을 의미하는 정수 값)
#define FIX_MASK     (FIX_SCALE - 1)  // 0xFF (소수부 비트 마스크)
#define FIX_ONE      FIX_SCALE        // 1.0


// -------------------------------------------------------------------------
// 2. 자료형 정의 (Typedef)
// -------------------------------------------------------------------------
// int와 같지만, "이 변수는 256배 튀겨진 값이다"라고 명시하기 위해 사용합니다.
typedef int fixed;


// -------------------------------------------------------------------------
// 3. 변환 매크로 (Conversion Macros)
// -------------------------------------------------------------------------

// [정수 -> 고정 소수점] (Enter Physics World)
// 사용: 초기값 설정, 정수 더하기
// 예: INT_TO_FIX(10) -> 2560
#define INT_TO_FIX(n)    ((fixed)((n) << FIX_SHIFT))

// [실수 -> 고정 소수점] (Data Import)
// 사용: 물리 상수 초기화 (예: 중력 9.8, 마찰력 0.1)
// 주의: float 연산이 포함되므로 '초기화 단계'에서만 사용할 것. 루프 내부 금지.
#define FLOAT_TO_FIX(f)  ((fixed)((f) * (float)FIX_SCALE))

// [고정 소수점 -> 정수 (버림)] (Render to Hardware)
// 사용: 최종적으로 화면(VRAM)에 좌표를 찍을 때
// 예: 2560(10.0) -> 10, 2688(10.5) -> 10
#define FIX_TO_INT(n)    ((n) >> FIX_SHIFT)

// [고정 소수점 -> 정수 (반올림)] (Render Precise)
// 사용: 더 정확한 좌표가 필요할 때
// 예: 10.5 -> 11, 10.4 -> 10
#define FIX_ROUND(n)     (((n) + (FIX_SCALE / 2)) >> FIX_SHIFT)

// [고정 소수점 -> 실수] (Debugging)
// 사용: printf 등으로 값을 확인하고 싶을 때
// 주의: 절대 게임 로직이나 연산용으로 사용하지 말 것 (매우 느림).
#define FIX_TO_FLOAT(n)  ((float)(n) / (float)FIX_SCALE)


// -------------------------------------------------------------------------
// 4. 산술 연산 함수 (Arithmetic Functions)
// -------------------------------------------------------------------------

// [덧셈/뺄셈]
// 그냥 + - 연산자를 사용하면 됩니다. (비트 이동 필요 없음)
// fixed c = a + b;


// [곱셈]
// 원리: (A * 256) * (B * 256) = (A * B) * 65536
// 결과가 256^2배가 되므로, 다시 256(SHIFT)으로 나눠줘야 원래 스케일로 돌아옴.
// (long long) 캐스팅: 32비트끼리 곱하면 오버플로우가 발생할 수 있어 64비트로 확장.
static inline fixed fix_mul(fixed a, fixed b) {
    return (fixed)(((long long)a * b) >> FIX_SHIFT);
}

// [나눗셈]
// 원리: (A * 256) / (B * 256) = A / B (스케일 소실됨)
// 미리 A에 256을 한번 더 곱해놓고 나눠야 스케일(256배)이 유지됨.
static inline fixed fix_div(fixed a, fixed b) {
    return (fixed)(((long long)a << FIX_SHIFT) / b);
}

// [절댓값]
static inline fixed fix_abs(fixed a) {
    return (a < 0) ? -a : a;
}

// [최소값]
static inline fixed fix_min(fixed a, fixed b) {
    return (a < b) ? a : b;
}

// [최대값]
static inline fixed fix_max(fixed a, fixed b) {
    return (a > b) ? a : b;
}

#endif // FIXED_H


================================================
FILE: include/gba.h
================================================
#ifndef GBA_H
#define GBA_H

// =========================================================================
// 1. 기본 자료형 (Primitive Types)
// -------------------------------------------------------------------------
// GBA(ARM7TDMI)는 32비트 RISC CPU입니다.
// C언어의 'int' 크기는 컴파일러마다 다를 수 있으므로, 
// 하드웨어 비트 수에 딱 맞는 명시적인 타입을 사용하는 것이 표준입니다.
// =========================================================================

#include <stdbool.h> // 표준 bool, true, false 사용 (C99/C23 호환)
#include <stddef.h>  // 표준 NULL 사용

typedef unsigned char  u8;  // 8비트 (1바이트): 타일 인덱스, 작은 정수 등
typedef unsigned short u16; // 16비트 (2바이트): 색상(RGB555), 레지스터 제어 등 주력 타입
typedef unsigned int   u32; // 32비트 (4바이트): 메모리 주소, 큰 데이터, DMA 전송 시 사용


// =========================================================================
// 2. 메모리 맵 (Memory Map)
// -------------------------------------------------------------------------
// GBA는 OS가 없습니다. 특정 메모리 주소에 값을 쓰면 하드웨어가 즉시 반응합니다.
// 이를 Memory Mapped I/O (MMIO)라고 합니다.
// =========================================================================

#define REG_BASE        0x04000000 // I/O 레지스터들의 시작 주소
#define VRAM_BASE       0x06000000 // 비디오 메모리(화면 데이터) 시작 주소

// VRAM 포인터
// u16 포인터인 이유: VRAM은 보통 16비트(색상 값) 단위로 읽고 쓰기 때문입니다.
// volatile 필수: 컴파일러가 "아까 썼으니까 안 써도 되겠지?"라고 최적화하는 것을 막습니다.
#define VRAM            ((volatile u16*)VRAM_BASE)

// =========================================================================
// 3. 하드웨어 레지스터 (Hardware Registers)
// -------------------------------------------------------------------------
// 주소 앞에 *(volatile 타입 *)을 붙이는 이유:
// 1. (volatile 타입 *): 정수 숫자를 '포인터(주소)'로 취급해라.
// 2. *: 그 포인터가 가리키는 실제 '값'을 가져오거나 수정해라 (Dereference).
// =========================================================================

// [디스플레이 제어]
// 주소: 0x04000000
// 타입: u32 (본래 u16이지만, 32비트 버스 효율을 위해 u32로 접근하기도 함)
// 역할: 화면 모드(0~5), 배경 활성화, 스프라이트 활성화 등 총괄 설정
#define REG_DISPCNT     (*(volatile u32*)(REG_BASE + 0x0000))

// [수직 라인 카운터 (Scanline Counter)]
// 주소: 0x04000006
// 타입: u16 (0~227 범위)
// 역할: 현재 전자총이 그리고 있는 가로줄 번호를 읽음 (Read-Only). VSync 구현의 핵심.
#define REG_VCOUNT      (*(volatile u16*)(REG_BASE + 0x0006))

// [키 입력 상태]
// 주소: 0x04000130
// 타입: u16 (총 10개 버튼이므로 10비트 사용)
// 역할: 버튼이 눌렸는지 확인. (주의: 눌리면 0, 안 눌리면 1 -> Active Low)
#define REG_KEYINPUT    (*(volatile u16*)(REG_BASE + 0x0130))

// =========================================================================
// 4. 설정 상수 (Configuration Constants)
// =========================================================================

// 화면 크기 (물리적 해상도 고정)
#define SCREEN_W        240
#define SCREEN_H        160

// 디스플레이 모드 설정 비트
// REG_DISPCNT에 OR(|) 연산으로 설정함
#define MODE_3          0x0003 // 비트맵 모드 (240x160, 트루컬러)
#define BG2_ENABLE      0x0400 // 배경 레이어 2 켜기 (Mode 3는 BG2를 사용함)

// =========================================================================
// 5. 색상 매크로 (Color Macros)
// -------------------------------------------------------------------------
// GBA는 15비트 색상(BGR555)을 사용합니다. 
// 포맷: XBBBBBGGGGGRRRRR (MSB 1비트는 사용 안 함)
// 각 채널 범위: 0 ~ 31
// =========================================================================

#define RGB(r, g, b)    ((u16)((r) | ((g) << 5) | ((b) << 10)))

#define COLOR_BLACK     RGB(0,  0,  0)
#define COLOR_WHITE     RGB(31, 31, 31)
#define COLOR_RED       RGB(31, 0,  0)
#define COLOR_GREEN     RGB(0,  31, 0)
#define COLOR_BLUE      RGB(0,  0,  31)
#define COLOR_GOLD      RGB(31, 25, 0)
#define COLOR_CYAN      RGB(0,  31, 31)
#define COLOR_MAGENTA   RGB(31, 0,  31)

// =========================================================================
// 6. 키 마스크 (Input Key Masks)
// -------------------------------------------------------------------------
// REG_KEYINPUT의 특정 비트만 쏙 뽑아내기 위한 필터(Mask)입니다.
// =========================================================================

#define KEY_A           0x0001 // 0번 비트
#define KEY_B           0x0002 // 1번 비트
#define KEY_SELECT      0x0004 // 2번 비트
#define KEY_START       0x0008 // 3번 비트
#define KEY_RIGHT       0x0010 // 4번 비트
#define KEY_LEFT        0x0020 // 5번 비트
#define KEY_UP          0x0040 // 6번 비트
#define KEY_DOWN        0x0080 // 7번 비트
#define KEY_R           0x0100 // 8번 비트
#define KEY_L           0x0200 // 9번 비트

// =========================================================================
// 7. 인라인 유틸리티 함수 (Inline Utilities)
// -------------------------------------------------------------------------
// 'static inline'을 쓰면 함수 호출 오버헤드 없이 코드가 그 자리에 복사됩니다.
// 헤더 파일에 구현할 때 가장 좋은 방법입니다.
// =========================================================================

// VSync 대기 함수
// 1. 현재 VBlank 중(화면 밖)이라면 다음 프레임까지 기다림 (REG_VCOUNT >= 160)
// 2. 화면을 그리는 중이라면, 다 그릴 때까지(160줄이 될 때까지) 기다림
static inline void sync_vblank() {
    while (REG_VCOUNT >= 160); // VBlank 중이면 대기
    while (REG_VCOUNT < 160);  // VDraw 중이면 대기
}

#endif


================================================
FILE: sandbox/input_test.c
================================================
// input_test.c
// GBA Bare-metal Programming: Input, Movement, and Rendering
// ---------------------------------------------------------

#include <stdbool.h> // bool 타입을 사용하기 위한 표준 헤더

// ---------------------------------------------------------
// 1. 자료형 및 레지스터 정의 (Memory Mapped I/O)
// ---------------------------------------------------------
typedef unsigned short u16;
typedef unsigned int   u32;

#define REG_BASE        0x04000000
#define VRAM            ((volatile u16*)0x06000000)

// [레지스터 매핑]
// volatile 키워드 필수: 하드웨어에 의해 값이 언제든 바뀔 수 있으므로, 
// 컴파일러가 최적화(캐싱)하지 않고 매번 메모리 주소에서 직접 읽도록 강제함.
#define REG_DISPCNT     (*(volatile u32*)(REG_BASE + 0x0000)) // 디스플레이 제어
#define REG_VCOUNT      (*(volatile u16*)(REG_BASE + 0x0006)) // 수직 라인 카운터 (Scanline)
#define REG_KEYINPUT    (*(volatile u16*)(REG_BASE + 0x0130)) // 키 입력 상태

// [설정 상수]
#define MODE_3          0x0003 // 비트맵 모드 (240x160, 16bit Color)
#define BG2_ENABLE      0x0400 // 배경 레이어 2 활성화
#define SCREEN_W        240
#define SCREEN_H        160

// ---------------------------------------------------------
// 2. 색상 및 키 매크로
// ---------------------------------------------------------

// [RGB 매크로]
// GBA는 15bit 색상(0BBBBBGGGGGRRRRR)을 사용함.
// 각 채널 범위: 0 ~ 31
#define RGB(r, g, b)    ((u16)((r) | ((g) << 5) | ((b) << 10)))

// [기본 색상]
#define COLOR_BLACK     RGB(0,  0,  0)
#define COLOR_WHITE     RGB(31, 31, 31)
#define COLOR_RED       RGB(31, 0,  0)
#define COLOR_GREEN     RGB(0,  31, 0)
#define COLOR_BLUE      RGB(0,  0,  31)
#define COLOR_GOLD      RGB(31, 25, 0)

// [키 마스크]
// 각 비트가 버튼 하나에 대응됨.
#define KEY_A           0x0001
#define KEY_B           0x0002
#define KEY_SELECT      0x0004
#define KEY_START       0x0008
#define KEY_RIGHT       0x0010
#define KEY_LEFT        0x0020
#define KEY_UP          0x0040
#define KEY_DOWN        0x0080
#define KEY_R           0x0100
#define KEY_L           0x0200

// ---------------------------------------------------------
// 3. 전역 상태 변수 (Global State)
// ---------------------------------------------------------

// 플레이어 정보
// 초기 위치를 화면 중앙으로 설정 (Pivot 보정: 크기의 절반만큼 뺌)
const int p_w = 10;
const int p_h = 10;
const int speed = 2;
int p_x = (SCREEN_W / 2) - p_w / 2;
int p_y = (SCREEN_H / 2) - p_h / 2;

// ---------------------------------------------------------
// 4. 유틸리티 함수
// ---------------------------------------------------------

// 화면 전체 지우기 (초기화 및 배경 변경 시 사용)
void clear_screen(u16 color) {
    for (int i = 0; i < SCREEN_W * SCREEN_H; ++i) {
        VRAM[i] = color;
    }
}

// 사각형 그리기 (클리핑 포함)
void draw_rect(int x, int y, int w, int h, u16 color) {
    for (int row = 0; row < h; ++row) {
        for (int col = 0; col < w; ++col) {
            // model Space -> Screen Space 변환
            int draw_x = x + col;
            int draw_y = y + row;

            // [클리핑 (Clipping)]
            // 화면 밖의 좌표에 쓰려고 하면 메모리 침범(Memory Corruption) 발생 위험.
            // 유효한 좌표 범위 내에서만 그리기 수행.
            if (draw_x >= 0 && draw_x < SCREEN_W && draw_y >= 0 && draw_y < SCREEN_H) {
                VRAM[draw_y * SCREEN_W + draw_x] = color;
            }
        }
    }
}

// 수직 동기화 (VSync)
// 화면 갱신 중에 VRAM을 건드리면 '티어링(Tearing)' 현상 발생.
// 전자총이 그림을 다 그리고 처음으로 돌아가는 VBlank 구간(160~227)을 기다림.
void sync_vblank() {
    // 1. 이미 VBlank 중이라면 다음 프레임까지 대기 (Edge Trigger 유도)
    while (REG_VCOUNT >= 160);
    // 2. VBlank가 시작될 때까지 대기
    while (REG_VCOUNT < 160);
}

// ---------------------------------------------------------
// 5. 메인 함수 (Game Loop)
// ---------------------------------------------------------
int main() {
    // 하드웨어 초기화
    REG_DISPCNT = MODE_3 | BG2_ENABLE;

    // 초기 렌더링
    u16 background_color = COLOR_BLACK;
    clear_screen(background_color);
    draw_rect(p_x, p_y, p_w, p_h, COLOR_BLUE);

    while (1) {
        // --------------------------------------
        // [Step 1] 입력 처리 및 상태 갱신 (Update)
        // --------------------------------------
        
        // 잔상 처리를 위해 이동 전 좌표 기억
        int old_x = p_x;
        int old_y = p_y;

        // 키 입력 레지스터 읽기
        u16 key_state = REG_KEYINPUT;

        // 1-1. 배경 색상 변경 로직
        // GBA 버튼은 Active Low 방식 (눌림=0, 뗌=1).
        // 따라서 비트 마스킹 결과가 0일 때가 '눌린 상태'임.
        u16 new_bg_color = background_color;

        if      ( !(key_state & KEY_A) )      new_bg_color = COLOR_RED;
        else if ( !(key_state & KEY_B) )      new_bg_color = COLOR_GOLD;
        else if ( !(key_state & KEY_L) )      new_bg_color = COLOR_GREEN;
        else if ( !(key_state & KEY_R) )      new_bg_color = COLOR_WHITE;
        else if ( !(key_state & KEY_SELECT) ) new_bg_color = COLOR_BLACK;

        // [최적화 핵심]
        // 매 프레임 clear_screen을 호출하면 CPU 부하가 심해짐.
        // 상태(색상)가 실제로 바뀌었을 때만 화면 전체 갱신 수행.
        if (new_bg_color != background_color) {
            background_color = new_bg_color;
            clear_screen(background_color);
            // 배경을 지우면 플레이어도 지워지므로 즉시 다시 그림
            draw_rect(p_x, p_y, p_w, p_h, COLOR_BLUE);
        }

        // 1-2. 이동 로직
        if ( !(key_state & KEY_UP) )    p_y -= speed;
        if ( !(key_state & KEY_DOWN) )  p_y += speed;
        if ( !(key_state & KEY_LEFT) )  p_x -= speed;
        if ( !(key_state & KEY_RIGHT) ) p_x += speed;

        // 화면 밖으로 나가지 않도록 좌표 고정 (Clamping)
        if (p_x < 0) p_x = 0;
        if (p_x > SCREEN_W - p_w) p_x = SCREEN_W - p_w;
        if (p_y < 0) p_y = 0;
        if (p_y > SCREEN_H - p_h) p_y = SCREEN_H - p_h;


        // --------------------------------------
        // [Step 2] 타이밍 동기화 (Sync)
        // --------------------------------------
        sync_vblank();


        // --------------------------------------
        // [Step 3] 렌더링 (Render)
        // --------------------------------------
        
        // [더티 렉탱글 (Dirty Rectangle)]
        // 화면 전체를 지우지 않고, 움직임이 발생한 부분만 수정함.
        if (p_x != old_x || p_y != old_y) {
            // 1. 이전 위치 지우기: 현재 배경색으로 덮어씀 (잔상 제거)
            draw_rect(old_x, old_y, p_w, p_h, background_color);
            
            // 2. 새 위치 그리기: 플레이어 색상으로 그림
            draw_rect(p_x, p_y, p_w, p_h, COLOR_BLUE);
        }
    }

    return 0;
}

